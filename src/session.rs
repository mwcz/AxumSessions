use crate::{cookies::*, AxumDatabasePool, AxumSessionData, AxumSessionID, AxumSessionStore};
use async_trait::async_trait;
use axum_core::{
    extract::{FromRef, FromRequestParts},
    response::{IntoResponse, IntoResponseParts, Response, ResponseParts},
};
use chrono::Utc;
use cookie::CookieJar;
use http::{self, request::Parts};
use serde::{de::DeserializeOwned, Serialize};
use std::{
    boxed::Box,
    convert::Infallible,
    fmt::Debug,
    marker::{Send, Sync},
};
use uuid::Uuid;

/// A Session Store.
///
/// Provides a Storage Handler to AxumSessionStore and contains the AxumSessionID(UUID) of the current session.
///
/// This is Auto generated by the Session Layer Upon Service Execution.
#[derive(Debug, Clone)]
pub struct AxumSession<T>
where
    T: AxumDatabasePool + Clone + Debug + Sync + Send + 'static,
{
    pub(crate) store: AxumSessionStore<T>,
    pub(crate) id: AxumSessionID,
    pub(crate) accepted: bool,
}

/// Adds FromRequestParts<B> for AxumSession
///
/// Returns the AxumSession from Axums request extensions state.
#[async_trait]
impl<T, S> FromRequestParts<S> for AxumSession<T>
where
    T: AxumDatabasePool + Clone + Debug + Sync + Send + 'static,
    S: Send + Sync,
    AxumSessionStore<T>: FromRef<S>,
{
    type Rejection = Infallible;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        let store = AxumSessionStore::<T>::from_ref(state);
        let cookies = get_cookies(&mut parts.headers);
        let accepted = cookies
            .get_cookie(&store.config.storable_cookie_name, &store.config.key)
            .map_or(false, |c| c.value().parse().unwrap_or(false));
        let session = AxumSession::new(store, &cookies, accepted);

        // Check if the session id exists if not lets check if it exists in the database or generate a new session.
        if !session.service_session_data() {
            let mut data = session
                .store
                .load_session(session.id.inner())
                .await
                .ok()
                .flatten()
                .unwrap_or_else(|| {
                    AxumSessionData::new(session.id.0, accepted, &session.store.config)
                });

            if !data.validate() || data.destroy {
                data.destroy = false;
                data.data.clear();
                data.autoremove = Utc::now() + session.store.config.memory_lifespan;
            }

            session.store.inner.insert(session.id.inner(), data);
        }

        let (last_sweep, last_database_sweep) = {
            let timers = session.store.timers.read().await;
            (timers.last_expiry_sweep, timers.last_database_expiry_sweep)
        };

        // This branch runs less often, and we already have write access,
        // let's check if any sessions expired. We don't want to hog memory
        // forever by abandoned sessions (e.g. when a client lost their cookie)
        // throttle by memory lifespan - e.g. sweep every hour
        if last_sweep <= Utc::now() {
            session
                .store
                .inner
                .retain(|_k, v| v.autoremove > Utc::now());
            session.store.timers.write().await.last_expiry_sweep =
                Utc::now() + session.store.config.memory_lifespan;
        }

        // Throttle by database lifespan - e.g. sweep every 6 hours
        if last_database_sweep <= Utc::now() && session.store.is_persistent() {
            session.store.cleanup().await.unwrap();
            session
                .store
                .timers
                .write()
                .await
                .last_database_expiry_sweep = Utc::now() + session.store.config.lifespan;
        }

        Ok(session)
    }
}

impl<T> IntoResponseParts for AxumSession<T>
where
    T: AxumDatabasePool + Clone + Debug + Sync + Send + 'static,
{
    type Error = Infallible;

    fn into_response_parts(self, mut res: ResponseParts) -> Result<ResponseParts, Self::Error> {
        let storable = if let Some(session_data) = self.store.inner.get(&self.id.inner()) {
            session_data.storable
        } else {
            false
        };

        let mut cookies = CookieJar::new();
        // Add the Storable Cookie so we can keep track if they can store the session.
        cookies.add_cookie(
            create_cookie(
                &self.store.config,
                storable.to_string(),
                CookieType::Storable,
            ),
            &self.store.config.key,
        );

        // Add the Session ID so it can link back to a Session if one exists.
        cookies.add_cookie(
            create_cookie(&self.store.config, self.id.inner(), CookieType::Data),
            &self.store.config.key,
        );

        set_cookies(cookies, res.headers_mut());

        Ok(res)
    }
}

impl<T> IntoResponse for AxumSession<T>
where
    T: AxumDatabasePool + Clone + Debug + Sync + Send + 'static,
{
    fn into_response(self) -> Response {
        (self, ()).into_response()
    }
}

impl<S> AxumSession<S>
where
    S: AxumDatabasePool + Clone + Debug + Sync + Send + 'static,
{
    pub(crate) fn new(
        store: AxumSessionStore<S>,
        cookies: &CookieJar,
        accepted: bool,
    ) -> AxumSession<S> {
        let value = cookies
            .get_cookie(&store.config.cookie_name, &store.config.key)
            .and_then(|c| Uuid::parse_str(c.value()).ok());

        let uuid = match value {
            Some(v) => v,
            None => loop {
                let token = Uuid::new_v4();

                if !store.inner.contains_key(&token.to_string()) {
                    break token;
                }
            },
        };

        AxumSession {
            id: AxumSessionID(uuid),
            store,
            accepted,
        }
    }
    /// Runs a Closure upon the Current Sessions stored data to get or set session data.
    ///
    /// Provides an Option<T> that returns the requested data from the Sessions store.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.tap(|sess| {
    ///   let string = sess.data.get(key)?;
    ///   serde_json::from_str(string).ok()
    /// }).await;
    /// ```
    ///
    #[inline]
    pub(crate) fn tap<T: DeserializeOwned>(
        &self,
        func: impl FnOnce(&mut AxumSessionData) -> Option<T>,
    ) -> Option<T> {
        if let Some(mut instance) = self.store.inner.get_mut(&self.id.0.to_string()) {
            func(&mut instance)
        } else {
            tracing::warn!("Session data unexpectedly missing");
            None
        }
    }

    /// Sets the Current Session to be Destroyed on the next run.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.destroy().await;
    /// ```
    ///
    #[inline]
    pub async fn destroy(&self) {
        self.tap(|sess| {
            sess.destroy = true;
            Some(1)
        });
    }

    /// Sets the Current Session to a long term expiration. Useful for Remember Me setups.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.set_longterm(true).await;
    /// ```
    ///
    #[inline]
    pub async fn set_longterm(&self, longterm: bool) {
        self.tap(|sess| {
            sess.longterm = longterm;
            sess.update = true;
            Some(1)
        });
    }

    /// Sets the Current Session to be storable.
    ///
    /// This will allow the Session to save its data for the lifetime if set to true.
    /// If this is set to false it will unload the stored session.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.set_store(true).await;
    /// ```
    ///
    #[inline]
    pub async fn set_store(&self, storable: bool) {
        self.tap(|sess| {
            sess.storable = storable;
            sess.update = true;
            Some(1)
        });
    }

    /// Gets data from the Session's HashMap
    ///
    /// Provides an Option<T> that returns the requested data from the Sessions store.
    /// Returns None if Key does not exist or if serdes_json failed to deserialize.
    ///
    /// # Examples
    /// ```rust ignore
    /// let id = session.get("user-id").await.unwrap_or(0);
    /// ```
    ///
    ///Used to get data stored within SessionDatas hashmap from a key value.
    ///
    #[inline]
    pub async fn get<T: serde::de::DeserializeOwned>(&self, key: &str) -> Option<T> {
        self.tap(|sess| {
            let string = sess.data.get(key)?;
            serde_json::from_str(string).ok()
        })
    }

    /// Sets data to the Current Session's HashMap.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.set("user-id", 1).await;
    /// ```
    ///
    #[inline]
    pub async fn set(&self, key: &str, value: impl Serialize) {
        let value = serde_json::to_string(&value).unwrap_or_else(|_| "".to_string());

        self.tap(|sess| {
            if sess.data.get(key) != Some(&value) {
                sess.data.insert(key.to_string(), value);
                sess.update = true;
            }
            Some(1)
        });
    }

    /// Removes a Key from the Current Session's HashMap.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.remove("user-id").await;
    /// ```
    ///
    #[inline]
    pub async fn remove(&self, key: &str) {
        self.tap(|sess| {
            sess.update = true;
            sess.data.remove(key)
        });
    }

    /// Clears all data from the Current Session's HashMap.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.clear_all().await;
    /// ```
    ///
    #[inline]
    pub async fn clear_all(&self) {
        if let Some(mut instance) = self.store.inner.get_mut(&self.id.0.to_string()) {
            instance.data.clear();
        }

        if self.store.is_persistent() {
            self.store.clear_store().await.unwrap();
        }
    }

    /// Returns a i64 count of how many Sessions exist.
    ///
    /// If the Session is persistant it will return all sessions within the database.
    /// If the Session is not persistant it will return a count within AxumSessionStore.
    ///
    /// # Examples
    /// ```rust ignore
    /// let count = session.count().await;
    /// ```
    ///
    #[inline]
    pub async fn count(&self) -> i64 {
        if self.store.is_persistent() {
            self.store.count().await.unwrap_or(0i64)
        } else {
            self.store.inner.len() as i64
        }
    }

    /// Finalizes the Sessions data by updating the database. Hoping to get async IntoResponseParts.
    /// Till then this function will exist.
    ///
    /// # Examples
    /// ```rust ignore
    /// session.finalize().await;
    /// ```
    ///
    #[inline]
    pub async fn finalize(&self) {
        if (!self.store.config.session_mode.is_storable() || self.accepted)
            && self.store.is_persistent()
        {
            let sess = if let Some(mut sess) = self.store.inner.get_mut(&self.id.inner()) {
                if self.store.config.always_save
                    || sess.update
                    || sess.expires - Utc::now() <= self.store.config.expiration_update
                {
                    if sess.longterm {
                        sess.expires = Utc::now() + self.store.config.max_lifespan;
                    } else {
                        sess.expires = Utc::now() + self.store.config.lifespan;
                    };

                    sess.update = false;
                    Some(sess.clone())
                } else {
                    None
                }
            } else {
                None
            };

            if let Some(sess) = sess {
                self.store.store_session(&sess).await.unwrap()
            }
        }

        if self.store.config.session_mode.is_storable() && !self.accepted {
            self.store.inner.remove(&self.id.inner());

            // Also run this just in case it was stored in the database and they rejected storability.
            if self.store.is_persistent() {
                self.store.destroy_session(&self.id.inner()).await.unwrap();
            }
        }
    }

    /// Attempts to load check and clear Data.
    ///
    /// If no session is found returns false.
    pub(crate) fn service_session_data(&self) -> bool {
        if let Some(mut inner) = self.store.inner.get_mut(&self.id.inner()) {
            if !inner.validate() || inner.destroy {
                inner.destroy = false;
                inner.longterm = false;
                inner.data.clear();
            }

            inner.autoremove = Utc::now() + self.store.config.memory_lifespan;
            return true;
        }

        false
    }
}
